
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TerraTech
                                 A QGIS plugin
 Creates training sets for neural networks
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-13
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Sadkov S.A. / TerraTech
        email                : SergeiSadkov@terratech.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QThread, QObject, pyqtSignal
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTabWidget, QMessageBox
from qgis.core import QgsProject, Qgis
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .Razmetka_dockwidget import TerraTechDockWidget
import os.path

from .razmetka_classes import *
from .check_raster_files import *
from .paths import ClearFolder

init_logger(filename=FullPath(os.path.dirname(__file__), 'razmetka.log'))


class TerraTech:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TerraTech_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Razmetka')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'TerraTech')
        self.toolbar.setObjectName(u'TerraTech')

        #print "** INITIALIZING TerraTech"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TerraTech', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Razmetka/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Make Razmetka'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING TerraTech"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD TerraTech"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Razmetka'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    # set datatype to plugin elements
    def Set_lineEditDatatype(self, elem, elem_label, out_datatype):
        out_param = None
        elem = elem.strip()
        if elem:
            try:
                out_param = out_datatype(elem)
            except:
                self.iface.messageBar().pushMessage("Error",
                                                    "Некорректный тип данных для {}".format(elem_label.text()),
                                                    level=Qgis.Critical, duration=10)
        else:
            pass
        return out_param

    # get value from plugin checkbox
    def GetCheckBoxValue(self, checkbox_elem, checked, unchecked):
        state = int(checkbox_elem.checkState())
        if state == 2:
            value = checked
        else:
            value = unchecked

        return value

    # get dictionary of replaces from input text
    def GetReplaceDict(self, string):
        dict_replaces = {}
        if string:
            list_replaces = re.split(",", string)
            for el in list_replaces:
                el = el.strip()
                if re.search(':', el):
                    key, value = int(re.split(":", el)[0]), int(re.split(":", el)[1])
                    if isinstance(key, int) and isinstance(value, int):
                        dict_replaces[key] = value
                    else:
                        pass
                else:
                    pass
                    #self.iface.messageBar().pushMessage("Error", "Необходимо использовать разделитель ':' между исходным и новым значением замены", level=Qgis.Critical, duration=10)

        return dict_replaces

    # select 'a' or 'burn' option
    def SelectedParameter(self):
        selected_param = {}
        if self.dockwidget.lineEditPar__a.text():
            selected_param['a'] = self.dockwidget.lineEditPar__a.text()
        elif self.dockwidget.lineEditPar__burn.text():
            selected_param['burn'] = self.Set_lineEditDatatype(self.dockwidget.lineEditPar__burn.text(),
                                                               self.dockwidget.label__burn, int)
        elif self.dockwidget.lineEditPar__a.text() and self.dockwidget.lineEditPar__burn.text():
            pass
        else:
            pass

        return selected_param

    # get list of bands from input text
    def GetBandsList(self, elem):
        bands = []
        if elem:
            if re.search(',', elem):
                band_list = re.split(',', elem)
                try:
                    bands = [int(band) for band in band_list]
                except:
                    self.iface.messageBar().pushMessage("Error",
                                                        "Неверный ввод каналов", level=Qgis.Critical, duration=10)
            else:
                try:
                    bands.append(int(elem))
                except:
                    self.iface.messageBar().pushMessage("Error",
                                                        "Канал введён неверно", level=Qgis.Critical, duration=10)
        else:
            pass

        return bands

    # button to set insert of EPSG
    def InsertEPSG(self):
        state = int(self.dockwidget.checkBox_UTM.checkState())
        if state == 2:
            self.dockwidget.lineEditPar__EPSG.setEnabled(False)
        elif state == 0:
            self.dockwidget.lineEditPar__EPSG.setEnabled(True)
        else:
            pass

    # get EPSG value
    def GetProjectionIndex(self):
        state = int(self.dockwidget.checkBox_UTM.checkState())
        projection_index = None
        if state == 2:
            projection_index = 'UTM'
        elif state == 0:
            try:
                projection_index = int(self.dockwidget.lineEditPar__EPSG.text())
            except:
                self.iface.messageBar().pushMessage("Error",
                                                    "Неверный ввод проекции", level=Qgis.Critical, duration=10)
        else:
            pass
        return projection_index

    # read mask parameters
    def GetMaskParameters(self):
        selected_param = self.SelectedParameter()
        params = {
            'name_template': self.dockwidget.lineEditSource__NameTemplate.text().strip().rstrip('\\'),
            'set_satid': self.dockwidget.lineEditPar__set_satid.text().strip().rstrip('\\'),
            'set_objid': self.dockwidget.lineEditPar__set_objid.text().strip().rstrip('\\'),
            'set_appendix': self.dockwidget.lineEditPar__set_appendix.text().strip().rstrip('\\'),
            'replace': self.GetReplaceDict(
                self.dockwidget.textEditPar__replace.toPlainText().strip().rstrip('\\')),
            'empty': self.GetCheckBoxValue(
                self.dockwidget.checkBox__empty, True, False),
            'crop_mask': self.GetCheckBoxValue(
                self.dockwidget.checkBox__crop_mask, True, False),
            'crop_data': self.GetCheckBoxValue(
                self.dockwidget.checkBox__crop_data, True, False),
            'set_unmarked': self.Set_lineEditDatatype(
                self.dockwidget.lineEditPar__UnmarkedData.text(),
                self.dockwidget.label__UnmarkedData, int),
            'overwrite': self.GetCheckBoxValue(
                self.dockwidget.checkBox__overwrite, True, False),
            '__errors__': [],
        }
        mask_params = {**selected_param, **params}

        return mask_params

    def GetDataParameters(self):
        return {
            'EPSG': self.GetProjectionIndex(),
            'PixelSize': self.Set_lineEditDatatype(
                self.dockwidget.lineEditPar__PixelSize.text(),
                self.dockwidget.label__PixelSize, float),
            'NoDataValue': self.Set_lineEditDatatype(
                self.dockwidget.lineEditPar__NoDataValue.text(),
                self.dockwidget.label__NoDataValue, float),
            'Bands': self.GetBandsList(self.dockwidget.lineEditPar__Bands.text()),
            'NBITS': self.Set_lineEditDatatype(
                self.dockwidget.lineEditPar__BitDepth.text(),
                self.dockwidget.label__BitDepth, int),
            'DataType': self.dockwidget.comboBox__DataType.currentIndex(),
            'COMPRESS': self.dockwidget.comboBox__COMPRESS.currentText(),
            '__preserve_original_pixel_size__': self.GetCheckBoxValue(
                self.dockwidget.checkBox__preserve_original_pixel_size__, True, False)
        }

    def GetAllParameters(self):
        mask_params = self.GetMaskParameters()
        data_params = self.GetDataParameters()
        params = {**mask_params, **data_params}
        return params

    ## input rasters
    # choose directory of input images
    def SourceRasterFolder(self):
        source_folder = QFileDialog.getExistingDirectory(
            self.dockwidget, "Выберите исходную директорию растров ", "")
        if source_folder:
            self.dockwidget.lineEditSourceRasterFolder.setText(source_folder)

    def RasterFolder(self):
        return self.dockwidget.lineEditSourceRasterFolder.text().strip().rstrip('\\/')

    # get list of input images
    def GetRasterFiles(self):
        self.dockwidget.comboBoxSourceRasterFiles.clear()
        source_folder = self.RasterFolder()
        if source_folder:
            params = self.GetAllParameters()
            self.set.GetRaster(source_folder, params, target_path=params.get('name_template'))
            self.dockwidget.comboBoxSourceRasterFiles.clear()
            self.dockwidget.comboBoxSourceRasterFiles.addItems([mask_id for mask_id in self.set])

    ## input vectors
    # choose directory of input vector files
    def SourceVectorFolder(self):
        source_folder = QFileDialog.getExistingDirectory(
            self.dockwidget, "Выберите исходную директорию векторов ", "")
        if source_folder:
            self.dockwidget.lineEditSourceVectorFolder.setText(source_folder)

    def VectorFolder(self):
        return self.dockwidget.lineEditSourceVectorFolder.text().strip().rstrip('\\/')

    # get list of input images
    def GetVectorFiles(self):
        self.dockwidget.comboBoxSourceVectorFiles.clear()
        source_folder = self.VectorFolder()
        if source_folder:
            params = self.GetAllParameters()
            self.set.GetVector(source_folder, params, target_path=params.get('name_template'))
            self.dockwidget.comboBoxSourceVectorFiles.clear()
            self.dockwidget.comboBoxSourceVectorFiles.addItems([mask_id for mask_id in self.set])

    # clear set of images
    def clearSet(self):
        self.set.clear()
        self.dockwidget.lineEditSourceRasterFolder.clear()
        self.dockwidget.comboBoxSourceRasterFiles.clear()
        self.dockwidget.lineEditSourceVectorFolder.clear()
        self.dockwidget.comboBoxSourceVectorFiles.clear()
        self.dockwidget.textBrowserSource.clear()

    def ParametersToString(self, parameters, excel_path = 'params.xls', temp_dir = os.environ['TMP']):
        params_df = pd.read_excel(FullPath(self.plugin_dir, excel_path))
        legend_column = 'Параметр'
        if legend_column in params_df:
            values = params_df[legend_column].values
        else:
            raise LegendError(f'Legend column not found: {legend_column}')

        file = f'{temp_dir}\params.txt'
        with open(file, 'w') as f:
            for value, param in zip(values, list(parameters.items())):
                if param[0] == '__errors__':
                    pass
                else:
                    f.write(f'{value}: {param[1]}\n')
        f.close()

        with open(file, 'r') as f:
            data = f.read()
        f.close()
        os.remove(file)

        return data

    #set params of razmetka
    def SetParameters(self):
        parameters = self.GetAllParameters()
        if parameters:
            raster_folder = self.RasterFolder()
            vector_folder = self.VectorFolder()
            if raster_folder and vector_folder:
                self.set.clear()
                self.set.GetRaster(raster_folder, self.GetAllParameters())
                self.set.GetVector(vector_folder, self.GetAllParameters())
                # write parameters to textBrowser
                parameters['DataType'] = self.dockwidget.comboBox__DataType.currentText()
                data = self.ParametersToString(parameters, excel_path = 'params.xls', temp_dir = os.environ['TMP'])
                self.dockwidget.textBrowserSource.setText(data)

    def SetReplaceValues(self):
        try:
            replace_dict = self.GetReplaceDict(self.dockwidget.textEditPar__replace.toPlainText().strip().rstrip('\\'))
            for id in self.set:
                self.set[id].par['replace'] = replace_dict
        except:
            pass

    def ResultFolder(self):
        result_folder = QFileDialog.getExistingDirectory(
            self.dockwidget, "Выберите директорию папки с разметкой", "")
        self.dockwidget.lineEditResultFolder.setText(result_folder)
        self.set.CheckTargetFolder(target_folder=self.dockwidget.lineEditResultFolder.text())

    def OpenLegend(self):
        self.set.legend.openXls()

    def ClearResultFolder(self):
        target_folder = self.set.tfolder
        if target_folder is not None:
            if os.path.exists(target_folder):
                confirm_delete = checkDialog()
                # raise Exception(confirm_delete)
                if confirm_delete == 1024:
                    ClearFolder(target_folder)

    def ResultEstimate(self):
        self.set.legend.updateFromXls()
        result_folder = self.dockwidget.lineEditResultFolder.text()
        # self.set.analyzeSet(result_folder)
        self.create_thread_analyze()
        # self.dockwidget.textBrowserResult.setText(self.set.__repr__())

    def ResultMakeSet(self):
        self.set.legend.updateFromXls()
        result_folder = self.dockwidget.lineEditResultFolder.text()
        # self.set.MakeSet(result_folder)
        self.create_thread_write()
        # self.dockwidget.textBrowserResult.setText(self.set.__repr__())

    def updateProgressBar(self):
        self.dockwidget.progressBarResult.setValue(self.worker.progress)

    def updateTextBrowser(self):
        self.dockwidget.textBrowserResult.setText(self.worker.razmetka.__repr__())

    def create_thread_analyze(self):
        result_folder = self.dockwidget.lineEditResultFolder.text()
        self.thread = QThread()
        self.worker = Worker(self.set, result_folder)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.workerEstimate)
        self.worker.progressChanged.connect(self.updateProgressBar)
        self.worker.messChanged.connect(self.updateTextBrowser)
        self.worker.finished.connect(self.worker_finished)
        self.thread.finished.connect(self.thread.deleteLater)
        self.dockwidget.pushButtonResultFolderAnalyze.setEnabled(False)
        self.dockwidget.pushButtonResultFolderSave.setEnabled(False)
        self.thread.start()
        self.dockwidget.labelInfoResult.setText('Анализ...')

    def create_thread_write(self):
        result_folder = self.dockwidget.lineEditResultFolder.text()
        self.thread = QThread()
        self.worker = Worker(self.set, result_folder)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.workerSetMask)
        self.worker.progressChanged.connect(self.updateProgressBar)
        self.worker.messChanged.connect(self.updateTextBrowser)
        self.worker.finished.connect(self.worker_finished)
        self.thread.finished.connect(self.thread.deleteLater)
        self.dockwidget.pushButtonResultFolderAnalyze.setEnabled(False)
        self.dockwidget.pushButtonResultFolderSave.setEnabled(False)
        self.thread.start()
        self.dockwidget.labelInfoResult.setText('Запись...')

    def kill_thread(self):
        self.worker.cancel()

    def worker_finished(self, result):
        # catch an emitted object (other than bool) if needed
        self.dockwidget.progressBarResult.setValue(0)
        self.dockwidget.labelInfoResult.setText(result)
        self.dockwidget.textBrowserResult.setText(self.set.__repr__())
        self.dockwidget.pushButtonResultFolderAnalyze.setEnabled(True)
        self.dockwidget.pushButtonResultFolderSave.setEnabled(True)
        # if result:
            # self.dockwidget.labelInfoResult.setText(result)
        # elif not result:
            # self.dockwidget.labelInfoResult.setText('Выполнено!')
        self.thread.quit()  # IMPORTANT! emits thread.finished signal

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True
            self.set = Razmetka()
            self.set.legend.updateFromXls(FullPath(self.plugin_dir, 'default_legend.xls'))

            #print "** STARTING TerraTech"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)

            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = TerraTechDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            # read other inputs
            self.dockwidget.checkBox_UTM.clicked.connect(self.InsertEPSG)

            #raster files
            self.dockwidget.pushButtonSourceRasterFolder.clicked.connect(self.SourceRasterFolder)
            self.dockwidget.pushButtonSourceRasterFiles.clicked.connect(self.GetRasterFiles)

            #vector files
            self.dockwidget.pushButtonSourceVectorFolder.clicked.connect(self.SourceVectorFolder)
            self.dockwidget.pushButtonSourceVectorFiles.clicked.connect(self.GetVectorFiles)

            self.dockwidget.pushButtonSourceClear.clicked.connect(self.clearSet)
            self.dockwidget.pushButtonSetParameters.clicked.connect(self.SetParameters)
            # self.dockwidget.progressBarSource

            # Buttons on the Result tab
            self.dockwidget.pushButtonResultFolderSet.clicked.connect(self.ResultFolder)
            self.dockwidget.pushButtonResult__Legend.clicked.connect(self.OpenLegend)
            self.dockwidget.pushButtonResult__Clear.clicked.connect(self.ClearResultFolder)
            self.dockwidget.pushButtonResultFolderAnalyze.clicked.connect(self.ResultEstimate)
            self.dockwidget.pushButtonResultFolderSave.clicked.connect(self.ResultMakeSet)
            # self.dockwidget.progressBarResult
            # self.dockwidget.pushButtonResultFolderAnalyze.clicked.connect(self.create_thread)
            self.dockwidget.pushButtonCancelResults.clicked.connect(self.kill_thread)

            # Update replace values instantly for all scenes
            self.dockwidget.textEditPar__replace.textChanged.connect(self.SetReplaceValues)


class Worker(QObject):
    progressChanged = pyqtSignal()
    finished = pyqtSignal(object)
    cancelled = pyqtSignal()
    messChanged = pyqtSignal()

    def __init__(self, razmetka, folder):  # define additional constructor parameters if required
        QObject.__init__(self)
        self.progress = 0
        self.messages = ''
        self.isCancelled = False
        self.razmetka = razmetka
        self.folder = folder

    def workerEstimate(self):
        tfolder = self.razmetka.CheckTargetFolder(target_folder=self.folder)
        for i, id in enumerate(self.razmetka):
            try:
                self.razmetka[id].analyzeMask()
            except Exception as e:
                self.razmetka[id].errors.append(f'Estimate: {e}')
            self.setProgress(int(round(100 * (i+1) / len(self.razmetka))))
            if self.isCancelled:
                self.finished.emit('Анализ прерван пользователем')
                return
        self.finished.emit(f'Закончен анализ {len(self.razmetka)} объектов')  # emit an object if required
        return

    def workerSetMask(self):
        tfolder = self.razmetka.CheckTargetFolder(target_folder=self.folder)
        summary = {'SetFolder': tfolder, 'StartTime': datetime.now().isoformat()}
        if tfolder:
            for i, id in enumerate(self.razmetka):
                try:
                    if not self.razmetka[id].GetTargetPaths(tfolder, create_subdirs=True):
                        if not self.razmetka[id].analyzed:
                            self.razmetka[id].analyzeMask()
                        self.razmetka[id].writeMask()
                    else:
                        pass
                except Exception as e:
                    self.razmetka[id].errors.append(f'Write: {e}')
                self.setProgress(int(round((100 * (i+1)) / len(self.razmetka))))
                if self.isCancelled:
                    self.finished.emit('Запись прервана пользователем')
                    return
            summary.update({'MasksCount': len(self.razmetka), 'FinishTime': datetime.now().isoformat()})
            self.razmetka.writeMetadata(summary=summary)
            self.finished.emit(f'Закончена запись {len(self.razmetka)} объектов')  # emit an object if required
        else:
            self.finished.emit('Ошибка: не указана папка с разметкой!')
        return

    def setProgress(self, progressValue):
        self.progress = progressValue
        self.progressChanged.emit()

    def setMessages(self, text):
        self.messages = text
        self.messChanged.emit()

    def cancel(self):
        self.isCancelled = True
        self.cancelled.emit()


def checkDialog():
   msgBox = QMessageBox()
   # msgBox.setIcon(QMessageBox.Information)
   msgBox.setText("Вы действительно хотите очистить папку разметки и удалить все ранее созданные файлы?")
   msgBox.setWindowTitle("Подтверждите удаление файлов")
   msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
   # msgBox.buttonClicked.connect(msgButtonClick)

   returnValue = msgBox.exec()
   #if returnValue == QMessageBox.Ok:
      # print('OK clicked')
   return returnValue